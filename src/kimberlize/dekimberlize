#!/bin/sh

########################################################################
# dekimberlize
#
# A script that applies a Kimberlized virtual machine overlay to a base
# virtual machine in order to install an application and its
# dependencies on-the-fly.
#



########################################################################
# Functions to simplify code.
#


#
## Print the command's syntax.
#

function usage()
{
    echo "usage: `basename $0` [-d floppy-file] <[-f patch-file] || [-i URL]> <vm-name>"
}


#
## Cleanup any loose state and fail with bad exit status.
#

function failure()
{
    rm -f /tmp/dekimberlize.lock
    exit 1
}


#
## Check whether a virtual machine is running.  
##   $1: The vm's name or UUID
##   $?: 1 if running, 0 if not
#

function vm_running()
{
    uuid=`VBoxManage showvminfo $1 | grep UUID | head -1 | sed -e 's/ //g' | cut -f2 -d':'`
    running=`VBoxManage list runningvms | grep $uuid`

    if [ uuid = running ];
        return 1
    fi

    return 0
}


#
## Poll VirtualBox about a VM until it is running.
##   $1: The vm's name or UUID
##   $2: The number of seconds until timeout
##   $?: 1 if running, 0 if not
#

function sleep_until_vm_running()
{
    for ((i=0;i<$2;i+=1)); do
        vm_running $1
        vm_status=$?

        if [ $vm_status -eq 1 ]; then
            return 1
        fi
        sleep 1s
    done

    return 0
}


#
## Poll VirtualBox about a VM until it is stopped.
##   $1: The vm's name or UUID
##   $2: The number of seconds until timeout
##   $?: 1 if stopped, 0 if not
#

function sleep_until_vm_stopped()
{
    for ((i=0;i<$2;i+=1)); do
        vm_running $1
        vm_status=$?

        if [ $vm_status -eq 0 ]; then
            return 1
        fi
        sleep 1s
    done

    return 0
}


########################################################################
# Beginning of actual dekimberlize script execution
#
    
if [ $# -lt 3 ]; then
	usage
	exit 1
fi


homedir=`printenv HOME`


#
## Default variables for managing floppy disk attachment
## and binary difference detection.
#

floppy_original=""
floppy_copy=""
floppy_diff=""


########################################################################
# Process command-line options.
#

while getopts ":d:f:i:h" Option
do
  case $Option in

      d)
    floppy_original=$OPTARG
    floppy_copy="${OPTARG}.new"
    floppy_diff="${OPTARG}.diff"

    echo
    echo "Received floppy disk image file '$floppy_original'.."
    ;;
    
      f)
    patch_file=$OPTARG
    echo
    echo "Using kimberlize patch file '$patch_file'.."
    ;;

      i)
    patch_file=`basename $OPTARG`
    echo
    echo "Downloading and using kimberlize patch file '$patch_file'.."
    wget -O /tmp/$patch_file $OPTARG
    patch_file=/tmp/$patch_file
    ;;

      h)
    usage
    exit 0
    ;;
	    
      ?)
    usage
    exit 1
    ;;

    esac
done
shift $(($OPTIND-1))


########################################################################
# Check to see the environment is acceptable to execute in, i.e. that
# another dekimberlize process isn't already running, that necessary
# files exist in expected places, etc.
#

echo

if [ -d $homedir/.VirtualBox/Machines/$1/ ]; then
	echo "Found:  $homedir/.VirtualBox/Machines/$1/"
else
	echo "!! Could not find:"
	echo "       $homedir/.VirtualBox/Machines/$1/"
	echo "   Please check the name of your virtual machine."
	exit 1
fi

if [ -e $homedir/.VirtualBox/Machines/$1/$1.xml ]; then
	echo "Found:  $homedir/.VirtualBox/Machines/$1/$1.xml"
else
	echo "!! Could not find:"
	echo "       $homedir/.VirtualBox/Machines/$1/$1.xml"
	echo "   Please check that your VM state is not corrupt."
	exit 1
fi

if [ -e /tmp/dekimberlize.lock ]; then
	echo "!! Found:"
	echo "       /tmp/dekimberlize.lock"
	echo "   Another kimberlized application is running within VirtualBox."
    echo "   Please finish using it before trying another application."
	exit 1	
fi

touch /tmp/dekimberlize.lock
rm -f /tmp/dekimberlize_finished


########################################################################
# Apply kimberlized tarball to the specified VM, decompressing
# first if necessary.
#

echo
echo "Checking for compression.."
compressed=`echo $patch_file | grep lzma`
if [ "$compressed" != "" ]; then
    echo "Decompressing.."
    output_file=`basename $patch_file`
    output_file=/tmp/output_file
	lzcat $patch_file > $output_file
	patch_file=$output_file
	echo "New patch file: $patch_file"
fi

#
## Untar into VM's directory;  this will overwrite the .xml metadata file,
## add the Snapshots/*.vdi binary difference files to the disk state, and
## also add a .diff file repesenting the binary difference in memory state,
## which must be applied with xdelta.  Also, save the names of files
## we create.
#

echo
echo "Untarring.."
tar xf $patch_file -C $homedir/.VirtualBox/Machines/

mem_snapshot_uuid=`tar tf $patch_file | grep .diff | cut -f3 -d'/' | cut -f1 -d'.'`
mem_current_uuid=`cat $homedir/.VirtualBox/Machines/$1/$1.xml | grep stateFile | head -1 | cut -f12 -d'"' | cut -f2 -d'{' | cut -f1 -d'}'`
mem_current_file=$homedir/.VirtualBox/Machines/$1/Snapshots/{$mem_current_uuid}.sav
mem_snapshot_diff=$homedir/.VirtualBox/Machines/$1/Snapshots/${mem_snapshot_uuid}.diff
mem_snapshot_file=$homedir/.VirtualBox/Machines/$1/Snapshots/{$mem_snapshot_uuid}.sav
echo "Moving current memory state:"
echo "      $mem_current_file "
echo "  to snapshot:"
echo "      $mem_snapshot_file"
mv $mem_current_file $mem_snapshot_file

mv $homedir/.VirtualBox/Machines/$1/VirtualBox.xml $homedir/.VirtualBox/

echo
echo "Applying delta ($mem_snapshot_diff) of memory state.."
xdelta patch $mem_snapshot_diff $mem_snapshot_file $mem_current_file
chmod 600 $mem_current_file
rm $mem_snapshot_diff

echo
echo "Port forwarding (host:2222 -> guest:22).."
VBoxManage setextradata $1 "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/HostPort" 2222 > /dev/null
VBoxManage setextradata $1 "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/GuestPort" 22 > /dev/null
VBoxManage setextradata $1 "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/Protocol" TCP > /dev/null


########################################################################
# Launch VM using VirtualBox now that the application of the VM
# overlay is complete.
#

echo
echo "Resuming VM '$1'.."
VBoxManage startvm $1 > /dev/null
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed resuming VM
    failure 
fi


#
## Copy and attach a floppy disk image to a running VM, if
## the user has provided one.
#

if [ $floppy_original != "" ]; then

    echo
    echo "Copying '$floppy_original' to '$floppy_copy' and attaching"
    echo "it as a floppy disk to the VM.."
    cp $floppy_original $floppy_copy


    echo
    echo "Waiting for VM to load.."
    sleep_until_vm_running $1 300
    if [ $? -ne 1 ]; then
        echo "VM did not load! Stopping Dekimberlize process.."
        failure
    fi

    echo
    echo "Attaching floppy disk '$floppy_original' to VM.."
    VBoxManage controlvm $1 floppyattach $floppy_copy
    if [ $? -ne 0 ]; then
    	echo `basename $0`: error: failed attaching floppy disk 
    fi
else
    echo
    echo "Not attaching floppy disk to VM.."
fi


########################################################################
# Wait for the user to complete his interaction by waiting for the
# launcher application to signal us that the connection has been closed.
# This is done by touching /tmp/dekimberlize_finished in the host.
#

echo
echo "VM loaded! Waiting for the user to finish.."
while [ ! -e /tmp/dekimberlize_finished ]; do
	printf . || true
	sleep 1s
done

echo
echo "The user has ended the session."


########################################################################
# Now clean up, tossing the dirty state and removing the port forwarding.
#


#
## Detach floppy disk image.  This must be done while the virtual
## machine is running.
#

if [ $floppy_original != "" ]; then
    echo
    echo "Detaching floppy disk from VM.."
	VBoxManage controlvm $1 floppyattach none
    if [ $? -ne 0 ]; then
        echo `basename $0`: error: failed attaching floppy disk
    fi
fi


#
## Power down VM as quickly as possible.
#

echo
echo "Powering VM $1 down.."
VBoxManage controlvm $1 poweroff
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed powering VM down
    failure
fi


#
## Wait for powerdown to complete.
#

sleep_until_vm_stopped $1 30
if [ $? -ne 1 ]; then
    echo "VM did not stop! Stopping Dekimberlize process.."
    failure
fi


#
## Unregister floppy disk image (registering is a side effect 
## of attachment).
#

if [ $floppy_original != "" ]; then
    echo
    echo "Unregistering floppy disk with VirtualBox.."
	VBoxManage unregisterimage floppy $floppy_copy
    if [ $? -ne 0 ]; then
        echo `basename $0`: error: failed attaching floppy disk
    fi
fi


#
## Calculate the binary difference of the floppy image against a copy
## of itself saved before attachment.
#

echo
echo "Calculating the floppy's binary difference in file '$floppy_diff'.."
xdelta delta $floppy_original $floppy_copy $floppy_diff


#
## Revert the snapshot taken in the Kimberlize process, restoring the
## virtual machine to its base image.
#

echo
echo "Discarding dirty state and restoring the original VM image.."
VBoxManage snapshot $1 discardcurrent -all 
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed discarding VM state
    failure 
fi

VBoxManage setextradata $1 "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/HostPort" > /dev/null
VBoxManage setextradata $1 "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/GuestPort" > /dev/null
VBoxManage setextradata $1 "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/Protocol" > /dev/null


rm -f /tmp/dekimberlize.lock


echo
echo "Complete!"


########################################################################
# Miscellaneous Information:
#
# *.vdi represent virtual disk images.  The oldest is the original install,
#   stored in a user's ~/.VirtualBox/VDI/ directory.  It is kept pristine.
#   The active difference file is updated whenever the virtual disk is written,
#   and copied to a saved file whenever a snapshot is taken.
#
# *.sav represent saved runtime state, including both in-memory and on-disk
#   changes.  During snapshot, the entire file is saved, with on-disk changes
#   also replicated into a .vdi file.  They average 200-300 MB.
#
# It is expected that the launcher running on a display will hoard the
# "generic" pristine .vdi file as well as the snapshotted memory state.
#
