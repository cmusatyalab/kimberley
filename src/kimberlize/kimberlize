#!/bin/bash

########################################################################
# kimberlize
#
# A script that customizes a virtual machine with an application and
# determines the delta in VM state resulting from the customization.
#



########################################################################
# Functions to simplify code.
#


#
## Print the command's syntax.
#

usage()
{
    echo "usage: kimberlize [-e [-k encryption-key-file]] [-l login-name] [-p port] [-n]"
    echo "                    <vm-name> <install-script> <execute-script>"
}


#
## Check whether a virtual machine is running.
##   $1: The vm's name or UUID
##   $?: 1 if running, 0 if not
#

vm_running()
{
    uuid=`VBoxManage showvminfo $1 | grep UUID | head -1 | sed -e 's/ //g' | cut -f2 -d':'`
    running=`VBoxManage list runningvms | grep $uuid`

    if [ "$uuid" = "$running" ]; then
        return 1
    fi

    return 0
}


#
## Poll VirtualBox about a VM until it is running.
##   $1: The vm's name or UUID
##   $2: The number of seconds until timeout
##   $?: 1 if running, 0 if not
#

sleep_until_vm_running()
{
    for ((i=0;i<$2;i+=1)); do
        vm_running $1
        vm_status=$?

        if [ $vm_status -eq 1 ]; then
            return 1
        fi
        sleep 1s
    done

    return 0
}



if [ $# -lt 3 ]; then
	usage
	exit 1
fi

snapshot_name="base"
login_name="kimberley"
login_port=2222
compression=1
install_script=""
execute_script=""
encryption=0
encryption_keyfile=""
overlay_filename=""


while getopts ":l:np:ek:h" Option
do
	case $Option in
		e) 	
			echo "Enabling encryption.."
			encryption=1
			;;
		k) 	
			echo "Using encryption passphrase from file '$OPTARG'"
			encryption_keyfile=$OPTARG
			;;
		l) 	
			echo "Using login name '$OPTARG'.."
			login_name=$OPTARG
			;;
		n) 	
			echo "Disabling compression.."
			compression=0
			;;
		p) 	
			echo "Using port '$OPTARG'.."
			login_port=$OPTARG
			;;
		h)
			usage
			exit
			;;
		?)	
			usage
			exit
			;;
	esac
done
shift $(($OPTIND-1))

vm_name=$1
install_script=$2
execute_script=$3

if [ "$vm_name" = "" ]; then
	echo "error: No VM name supplied."
    usage
    exit 1
fi

if [ "$install_script" = "" ]; then
	echo "error: No application installation script supplied."
    usage
    exit 1
fi

if [ "$execute_script" = "" ]; then
	echo "error: No application execution script supplied."
    usage
    exit 1
fi


echo
echo "Installing application in VM '$vm_name'.."


########################################################################
# Port forward local port to VM (TCP host:2222->guest:22)
#

echo 
echo "Port forwarding (host:$login_port -> guest:22) for SSH.."
VBoxManage setextradata $vm_name "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/HostPort" $login_port > /dev/null
VBoxManage setextradata $vm_name "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/GuestPort" 22 > /dev/null
VBoxManage setextradata $vm_name "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/Protocol" TCP > /dev/null


########################################################################
# Create a preliminary snapshot of the virtual machine while it is suspended.
# This saves the in-memory state, allowing us to take a binary difference
# later.
#

echo
echo "Snapshotting VM '$vm_name'.."
VBoxManage snapshot $vm_name take $snapshot_name > /dev/null
if [ $? -ne 0 ]; then
	echo `basename $0`: error: failed taking VM snapshot
    exit 1
fi


########################################################################
# Launch VM using VirtualBox.  Now we will create our custom state.
#

echo
echo "Resuming VM '$vm_name'.."
VBoxManage startvm $vm_name > /dev/null
#-type vrdp
if [ $? -ne 0 ]; then
	echo `basename $0`: error: failed resuming VM
    exit 1
fi

echo
echo "Resuming.."
sleep_until_vm_running $vm_name 300

echo
echo "Sleeping 15 secs while the VM gets a network address.."
sleep 15s


########################################################################
# Execute application installer and application inside VM
#

echo
echo "Executing install script '$install_script' inside VM.."
install_basename=`basename $install_script`
scp -P $login_port $install_script $login_name@localhost:/tmp
ssh -t -l $login_name -p $login_port localhost /tmp/$install_basename

echo
echo "Executing application script '$execute_script' inside VM.."
execute_basename=`basename $execute_script`
scp -P $login_port $execute_script $login_name@localhost:/tmp
ssh -f -l $login_name -p $login_port localhost /tmp/$execute_basename
sleep 5s


########################################################################
# XXX EXPERIMENTAL
# Execute zerofree, which cleans freed blocks, increasing compressibility.
# This is turned off for now due to the fact that zerofree needs to
# change runlevels, which may trash memory state.

zf=`printenv ZEROFREE`;
if [ "$zf" != "" ]; then
	echo
	echo "Zerofree-ing the guest VM to decrease its size.."
	scp $zf $login_name@localhost:~/ :-P $login_port
	scp zerofree_script $login_name@localhost:~/ :-P $login_port
	sudo telinit 1
	ssh -f -l $login_name -p $login_port localhost ~/$zf
	sudo telinit 5
fi


########################################################################
# Tear down the VM, writing the in-memory state to disk (.sav)
#

echo
echo "Suspending VM $vm_name (saving state).."
VBoxManage controlvm $vm_name savestate > /dev/null
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed suspending VM state
    exit 1
fi


########################################################################
# Parse the various UUIDs used in filename construction.
#

mem_snapshot_uuid=`cat $HOME/.VirtualBox/Machines/$vm_name/$vm_name.xml | grep currentSnapshot | cut -f4 -d'"' | sed -e 's/{//g' | sed -e 's/}//g'`
mem_snapshot_file="$HOME/.VirtualBox/Machines/$vm_name/Snapshots/{${mem_snapshot_uuid}}.sav"

mem_current_uuid=`cat $HOME/.VirtualBox/Machines/$vm_name/$vm_name.xml | grep stateFile | head -1 | cut -f12 -d'"' | cut -f2 -d'{' | cut -f1 -d'}'` 
mem_current_file="$HOME/.VirtualBox/Machines/$vm_name/Snapshots/{${mem_current_uuid}}.sav"

disk_current_uuid=`cat $HOME/.VirtualBox/Machines/$vm_name/$vm_name.xml | grep hardDisk | tail -1 | cut -f6 -d'"' | sed -e 's/{//g' | sed -e 's/}//g'`
disk_current_file="$HOME/.VirtualBox/Machines/$vm_name/Snapshots/{${disk_current_uuid}}.vdi"


########################################################################
# Piece together the tarball that dekimberlize will use to apply state.
# Take binary diff of in-memory state using xdelta.
# This can vastly reduce the amount of memory transferred.
#

rm -rf /tmp/$vm_name/
mkdir -p /tmp/$vm_name/Snapshots/

echo
echo "Taking the delta between current in-memory state and the checkpoint's.."
xdelta delta $mem_snapshot_file $mem_current_file /tmp/$vm_name/Snapshots/${mem_snapshot_uuid}.diff

echo
echo "Taking the delta between current disk image and the checkpoint's.."
#scp $disk_current_file /tmp/$vm_name/Snapshots/
scp $HOME/.VirtualBox/Machines/$vm_name/Snapshots/*.vdi /tmp/$vm_name/Snapshots/
scp $HOME/.VirtualBox/Machines/$vm_name/$vm_name.xml /tmp/$vm_name/$vm_name.xml
scp $HOME/.VirtualBox/VirtualBox.xml /tmp/$vm_name/VirtualBox.xml

tar cf /tmp/${vm_name}-app_state.tar -C /tmp $vm_name
overlay_filename="/tmp/${vm_name}-app_state.tar"

ls -lR /tmp/$vm_name
rm -rf /tmp/$vm_name


########################################################################
# Now clean up, deleting the unnecessary checkpoint and removing
# the port forwarding.
#

echo
echo "Discarding new state of VM '$vm_name' and reverting to the checkpoint.."
VBoxManage snapshot $vm_name discardcurrent -all > /dev/null
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed discarding VM snapshot '$snapshot_name' 
fi

VBoxManage setextradata $vm_name "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/HostPort" > /dev/null
VBoxManage setextradata $vm_name "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/GuestPort" > /dev/null
VBoxManage setextradata $vm_name "VBoxInternal/Devices/pcnet/0/LUN#0/Config/diamond_ssh/Protocol" > /dev/null

echo
echo "VM returned to base state."

if [ $compression -eq 1 ]; then
    echo
    echo "Compressing VM overlay (LZMA).."
    lzcat $overlay_filename > ${overlay_filename}.lzma
    rm $overlay_filename
    overlay_filename=${overlay_filename}.lzma
else
    echo
    echo "Compression disabled, ignoring.."
fi


if [ $encryption -ne 0 ]; then
    echo
    echo "Encrypting VM overlay (AES-128).."
    if [ "$encryption_keyfile" != "" ]; then
	echo "  - Using passphrase from first line of supplied file '$encryption_keyfile'.."
    else
	encryption_keyfile="${overlay_filename}.key"
	od -X -A n -N 16 --width=32 /dev/urandom > $encryption_keyfile
	echo " - Generated encryption key in file '$encryption_keyfile'.."
    fi
    openssl enc -aes-128-cbc -e -pass file:$encryption_keyfile -in $overlay_filename -out ${overlay_filename}.enc
    rm $overlay_filename
    overlay_filename=${overlay_filename}.enc
else
    echo
    echo "Encryption disabled, ignoring.."
fi


echo
echo "Complete!  Your state is in the file '$overlay_filename'"
echo "It can be renamed to whatever you like, provided the extensions remain."
echo


########################################################################
# Info:
# *.vdi represent virtual disk images.  The oldest is the original install,
#   stored in a user's ~/.VirtualBox/VDI/ directory.  It is kept pristine.
#   The active difference file is updated whenever the virtual disk is written,
#   and copied to a saved file whenever a snapshot is taken.
#
# *.sav represent saved runtime state, including both in-memory and on-disk
#   changes.  During snapshot, the entire file is saved, with on-disk changes
#   also replicated into a .vdi file.  They average 200-300 MB.
#
# It is expected that the launcher running on a display will hoard the
# "generic" pristine .vdi file as well as the snapshotted memory state.
#
