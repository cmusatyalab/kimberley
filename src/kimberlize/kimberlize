#!/bin/bash
#
#  Kimberley
#
#  Copyright (c) 2008 Carnegie Mellon University
#  All rights reserved.
#
#  Kimberley is free software: you can redistribute it and/or modify
#  it under the terms of version 2 of the GNU General Public License
#  as published by the Free Software Foundation.
#
#  Kimberley is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with Kimberley. If not, see <http://www.gnu.org/licenses/>.
#

########################################################################
# kimberlize
#
# A script that customizes a virtual machine with an application and
# determines the delta in VM state resulting from the customization.
#



########################################################################
# Functions to simplify code.
#

#
## Executes commands in the virtual machine by sending them over a unix domain socket
#
RUN()
{
	cat > /tmp/kimberlize.py << EOF
import sys,socket
s = socket.socket(socket.AF_UNIX)
s.connect("/tmp/kimberley-COM1")
for cmd in sys.stdin:
  if cmd[0] == '#': continue
  print "Running:", cmd[:-1]
  s.send(cmd)
  out = ''
  while 1:
    out = out + s.recv(1024)
    if out[-4:] == '\r\n# ': break
    if out[-4:] == '\r\n$ ': break
  print out
s.close()
EOF
	python /tmp/kimberlize.py
}


#
## Print the command's syntax.
#
usage()
{
    echo "usage: kimberlize [-e [-k encryption-key-file]] [-n]"
    echo "                    <vm-name> <app-name> <install-script> <execute-script>"
}


#
## Poll VirtualBox about a VM until it is running.
##   $1: The vm's state
##   $2: The vm's name or UUID
##   $3: The number of seconds until timeout
##   $?: 1 if running, 0 if not
#
sleep_until_vm()
{
    for ((i=0;i<$3;i+=1)); do
	state=$(VBoxManage showvminfo "$2" -machinereadable | \
			sed -ne 's/^VMState="\(.*\)"/\1/p')
	[ "$state" = "$1" ] && return 1
        sleep 0.1s
    done
    return 0
}


if [ $# -lt 2 ]; then
	usage
	exit 1
fi

compression=1
install_script=""
execute_script=""
encryption=0
encryption_keyfile=""
overlay_filename=""


while getopts ":l:np:ek:h" Option
do
	case $Option in
		e) 	
			echo "Enabling encryption.."
			encryption=1
			;;
		k) 	
			echo "Using encryption passphrase from file '$OPTARG'"
			encryption_keyfile=$OPTARG
			;;
		n) 	
			echo "Disabling compression.."
			compression=0
			;;
		h)
			usage
			exit
			;;
		?)	
			usage
			exit
			;;
	esac
done
shift $(($OPTIND-1))

vm_name="$1"
app_name=$2
install_script=${3:-${app_name}-install}
execute_script=${4:-${app_name}-execute}
log_filename=$2.log


if [ "$vm_name" = "" ]; then
	echo "error: No VM name supplied."
    usage
    exit 1
fi

if [ "$install_script" = "" ]; then
	echo "error: No application installation script supplied."
    usage
    exit 1
fi

if [ "$execute_script" = "" ]; then
	echo "error: No application execution script supplied."
    usage
    exit 1
fi

KIMBERLIZESTART=$(date +%s)
echo "#`date` : Kimberlize begin. ${vm_name}/${install_script}/${execute_script}" >> ${log_filename}

echo
echo "Installing application in VM '$vm_name'.."


########################################################################
# Enable serial port and RDP over loopback
#
#VBoxManage modifyvm "$vm_name" -uartmode1 server /tmp/kimberley-COM1
#VBoxManage modifyvm "$vm_name" -vrdp on -vrdpaddress 127.0.0.1

########################################################################
# Create a preliminary snapshot of the virtual machine while it is suspended.
# This saves the in-memory state, allowing us to take a binary difference
# later.
#

START=$(date +%s)
echo
echo "Snapshotting VM '$vm_name'.."
VBoxManage snapshot "$vm_name" take kimberlize_base > /dev/null
if [ $? -ne 0 ]; then
	echo `basename $0`: error: failed taking VM snapshot
    exit 1
fi


########################################################################
# Launch VM using VirtualBox.  Now we will create our custom state.
#

echo
echo "Resuming VM '$vm_name'.."
VBoxManage startvm "$vm_name" > /dev/null
#-type vrdp
if [ $? -ne 0 ]; then
	echo `basename $0`: error: failed resuming VM
    exit 1
fi

echo
echo "Resuming.."
sleep_until_vm running "$vm_name" 300

END=$(date +%s)
DIFF=$(( $END - $START ))
echo "Snapshot, VM launch: $DIFF" >> ${log_filename}


########################################################################
# Execute application installer and application inside VM
#

START=$(date +%s)
echo
echo "Executing install script '$install_script' inside VM.."
( echo 'wget -O- http://128.2.216.108 >/dev/null' # wait for network
  cat "$install_script" ) | RUN

echo
echo "Executing application script '$execute_script' inside VM.."
( echo 'su -l -s /bin/sh kimberley'
  echo 'export DISPLAY=:0'
  cat "$execute_script" ) | RUN
sleep 2

END=$(date +%s)
DIFF=$(( $END - $START ))
echo "Application install and exec: $DIFF" >> ${log_filename}

########################################################################
# Tear down the VM, writing the in-memory state to disk (.sav)
#

echo
echo "Suspending VM $vm_name (saving state).."
VBoxManage controlvm "$vm_name" savestate > /dev/null
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed suspending VM state
    exit 1
fi


########################################################################
# Parse the various UUIDs used in filename construction.
#
vmpath="$HOME/.VirtualBox/Machines/$vm_name"
base_snapshot_uuid=$(VBoxManage showvminfo "$vm_name" -machinereadable |
	sed -ne 's/^SnapshotUUID="\(.*\)"$/\1/p')
base_mem_state="$vmpath/Snapshots/{$base_snapshot_uuid}.sav"

curr_snapshot_uuid=$(VBoxManage showvminfo "$vm_name" -machinereadable |
	sed -ne 's/^UUID="\(.*\)"$/\1/p')
curr_mem_state="$vmpath/Snapshots/{$curr_snapshot_uuid}.sav"

disk_snapshot_uuid=$(cat "$vmpath/$vm_name.xml" | 
	sed -ne 's/.*<HardDiskAttachment hardDisk="{\(.*\)}" .*/\1/p' | tail -1)
disk_snapshot_file="$vmpath/Snapshots/{$disk_snapshot_uuid}.vdi"


########################################################################
# Piece together the tarball that dekimberlize will use to apply state.
# Take binary diff of in-memory state using xdelta.
# This can vastly reduce the amount of memory transferred.
#

START=$(date +%s)
rm -rf "/tmp/$vm_name"
mkdir -p "/tmp/$vm_name"

diff_mem_state="/tmp/$vm_name/${curr_snapshot_uuid}.diff"

echo
echo "Taking the delta between current in-memory state and the checkpoint's.."
xdelta delta -0 "$base_mem_state" "$curr_mem_state" "$diff_mem_state"

echo
echo "Taking the delta between current disk image and the checkpoint's.."
cp "$disk_snapshot_file" "/tmp/$vm_name/overlay.vdi"

overlay_filename="/tmp/${vm_name}-${app_name}.tar"
tar cf "$overlay_filename" -C /tmp "$vm_name"

echo "Mem  diff (.diff) size: "$(wc -c "$diff_mem_state") >> ${log_filename}
echo "Disk diff (.vdi)  size: "$(wc -c "$disk_snapshot_file") >> ${log_filename}

ls -lR "/tmp/$vm_name"
rm -rf "/tmp/$vm_name"


########################################################################
# Now clean up, deleting the unnecessary checkpoint and removing
# the port forwarding.
#

echo
echo "Discarding modified state of VM '$vm_name' and reverting to the checkpoint.."
VBoxManage snapshot "$vm_name" discardcurrent -all >/dev/null
if [ $? -ne 0 ]; then
    echo `basename $0`: error: failed discarding VM snapshot
fi

echo
echo "VM returned to base state."

END=$(date +%s)
DIFF=$(( $END - $START ))
echo Uncompressed tarball creation: $DIFF >> ${log_filename}
echo Uncompressed tarball size: $(wc -c "$overlay_filename") >> ${log_filename}

if [ $compression -eq 1 ]; then
    echo
    START=$(date +%s)
    echo "Compressing VM overlay (LZMA).."
    lzma -c "$overlay_filename" > "${overlay_filename}.lzma"
    rm "$overlay_filename"
    overlay_filename="${overlay_filename}.lzma"
    END=$(date +%s)
    DIFF=$(( $END - $START ))
    echo Compressed   tarball size: $(wc -c "$overlay_filename") >> ${log_filename}
    echo Compression: $DIFF >> ${log_filename}
else
    echo
    echo "Compression disabled, ignoring.."
fi


if [ $encryption -ne 0 ]; then
    echo
    START=$(date +%s)
    echo "Encrypting VM overlay (AES-128).."
    if [ "$encryption_keyfile" != "" ]; then
	echo "  - Using passphrase from first line of supplied file '$encryption_keyfile'.."
    else
	encryption_keyfile="${overlay_filename}.key"
	od -A n -N 16 -t x8 /dev/urandom > "$encryption_keyfile"
	echo " - Generated encryption key in file '$encryption_keyfile'.."
    fi
    openssl enc -aes-128-cbc -e -pass "file:$encryption_keyfile" -in "$overlay_filename" -out "${overlay_filename}.enc"
    rm "$overlay_filename"
    overlay_filename="${overlay_filename}.enc"
    END=$(date +%s)
    DIFF=$(( $END - $START ))
    echo "Encryption: $DIFF" >> ${log_filename}
else
    echo
    echo "Encryption disabled, ignoring.."
fi

echo
echo "Complete!  Your state is in the file '$overlay_filename'"
echo "It can be renamed to whatever you like, provided the extensions remain."
echo

KIMBERLIZEEND=$(date +%s)
KIMBERLIZEDIFF=$(( $KIMBERLIZEEND - $KIMBERLIZESTART ))
echo "Kimberlize process: $KIMBERLIZEDIFF" >> ${log_filename}
echo "#`date` : Kimberlize end." >> ${log_filename}
echo "" >> ${log_filename}


########################################################################
# Info:
# *.vdi represent virtual disk images.  The oldest is the original install,
#   stored in a user's ~/.VirtualBox/VDI/ directory.  It is kept pristine.
#   The active difference file is updated whenever the virtual disk is written,
#   and copied to a saved file whenever a snapshot is taken.
#
# *.sav represent saved runtime state, including both in-memory and on-disk
#   changes.  During snapshot, the entire file is saved, with on-disk changes
#   also replicated into a .vdi file.  They average 200-300 MB.
#
# It is expected that the launcher running on a display will hoard the
# "generic" pristine .vdi file as well as the snapshotted memory state.
#
